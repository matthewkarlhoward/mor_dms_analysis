---
title: "Orthosteric site radar and bar plots"
output: html_notebook
---

data, directories, packages
```{r}
setwd("/Users/mkh/GitHub/mor_dms_analysis/analysis/radar_bar_plots")

# data directory
data_dir <- "/Users/mkh/GitHub/mor_dms_analysis/dms/alldrugs/scores"
# output directory
output_dir <- "/Users/mkh/GitHub/mor_dms_analysis/analysis/radar_bar_plots"

library(tidyverse)
library(circlize)
```

import the lilace_scores_wide_all.csv
```{r}
scores <- read_csv(file.path(data_dir, "lilace_scores_wide_all.csv"))
scores_expression_normalized <- read_csv(file.path(data_dir, "lilace_scores_wide_all_expression_norm.csv"))
```
# orthosteric resi. from GPCRdb
positions that interact with any tested ligand based on experimental structures 
77, 116, 119, 122, 123, 125, 126, 129, 130, 135, 145, 146, 149, 150, 152, 153, 156, 219, 220, 235, 238, 295, 298, 299, 302, 320, 321, 324, 327, 328, 330, 331
```{r}
orthosteric_pos <- c(77, 116, 119, 122, 123, 125, 126, 129, 130, 135, 145, 146, 149, 150, 152, 153, 156, 219, 220, 235, 238, 295, 298, 299, 302, 320, 321, 324, 327, 328, 330, 331)
```

# radar plots
basic radar plot for each ligand using the average effect at the orthosteric positions for mutation_type M
```{r}
# =============================================================================
# FUNCTION: Create Circos Plot for Effect Columns
# =============================================================================

create_circos_plot <- function(effect_column, scores_df, orthosteric_positions) {
  
  # --- Data Preparation ---
  cat("Creating plot for:", effect_column, "\n")
  
  # Calculate average effect for mutation type M at orthosteric positions
  df <- scores_df %>%
    filter(pos %in% orthosteric_positions, mutation_type == "M") %>%
    group_by(pos) %>%
    summarize(avg_effect = mean(.data[[effect_column]], na.rm = TRUE), .groups = 'drop') %>%
    mutate(pos = as.character(pos)) %>%
    # Include all orthosteric positions (fill missing with 0)
    right_join(data.frame(pos = as.character(orthosteric_positions)), by = "pos") %>%
    mutate(avg_effect = ifelse(is.na(avg_effect), 0, avg_effect)) %>%
    arrange(as.numeric(pos))
  
  # Create filename based on effect column
  filename <- paste0("circos_plot_", effect_column, ".pdf")
  
  # --- Save as PDF ---
  pdf(filename, width = 8, height = 9)
  
  # --- Circos Plot Setup ---
  circos.clear()
  circos.par(
    start.degree = 90,              # Start at top (12 o'clock)
    gap.after = 1,                  # Small gaps between sectors
    track.margin = c(0, 0),         # No track margins
    cell.padding = c(0, 0, 0, 0),   # No cell padding
    canvas.xlim = c(-1.2, 1.2),     # Canvas limits
    canvas.ylim = c(-1.4, 1.2)      # Extended bottom for better spacing
  )
  
  # Initialize circos with one sector per position
  circos.initialize(
    factors = df$pos,
    xlim = cbind(rep(0, nrow(df)), rep(1, nrow(df)))
  )
  
  # --- Create Radial Bar Plot ---
  circos.trackPlotRegion(
    ylim = c(0, max(df$avg_effect, na.rm = TRUE)),
    factors = df$pos,
    track.height = 1.0,
    bg.border = NA,
    panel.fun = function(x, y) {
      # Get current position and its value
      pos_label <- get.cell.meta.data("sector.index")
      val <- df$avg_effect[df$pos == pos_label]
      
      # Draw bar
      circos.barplot(val, 1, col = "grey60", border = NA)
      
      # Add position labels
      circos.text(0.5, val + max(df$avg_effect) * 0.05, pos_label,
                  facing = "downward",
                  niceFacing = FALSE,
                  adj = c(0.5, 0),
                  cex = 0.6)
    }
  )
  
  # --- Add Y-axis Reference ---
  circos.yaxis(
    side = "left",
    at = seq(0, max(df$avg_effect), length.out = 5),
    labels = round(seq(0, max(df$avg_effect), length.out = 5), 2),
    labels.cex = 0.6
  )
  
  # Clean up circos before adding title
  circos.clear()
  
  # --- Add Title ---
  title_text <- paste("Average", gsub("effect_", "", effect_column), "Effect")
  subtitle_text <- "Orthosteric Positions (Mutation M)"
  
  # Add title using text() for precise positioning
  text(x = 0.5, y = 0.95, title_text, 
       cex = 1.3, font = 2, xpd = TRUE)
  text(x = 0.5, y = 0.90, subtitle_text, 
       cex = 1.1, font = 1, xpd = TRUE)
  
  # Close PDF
  dev.off()
  
  # --- Summary ---
  cat("PDF saved as:", filename, "\n")
  cat("Plot created for", nrow(df), "orthosteric positions\n")
  cat("Effect range:", round(range(df$avg_effect, na.rm = TRUE), 3), "\n\n")
  
  return(filename)
}

# =============================================================================
# GENERATE PLOTS FOR ALL EFFECT COLUMNS
# =============================================================================

# Find all columns starting with "effect_"
effect_columns <- names(scores)[grepl("^effect_", names(scores))]
cat("Found effect columns:", paste(effect_columns, collapse = ", "), "\n\n")

# Generate plots for all effect columns
generated_files <- sapply(effect_columns, function(col) {
  create_circos_plot(col, scores, orthosteric_pos)
})

# Summary of all generated files
cat("=== SUMMARY ===\n")
cat("Generated", length(generated_files), "circos plots:\n")
for(i in seq_along(generated_files)) {
  cat(i, ".", generated_files[i], "\n")
}
```

basic radar plot for each ligand using the absolute sum effect at the orthosteric positions for mutation_type M
```{r}
# =============================================================================
# FUNCTION: Create Circos Plot for Effect Columns (Absolute Sum)
# =============================================================================

create_circos_plot <- function(effect_column, scores_df, orthosteric_positions) {
  
  # --- Data Preparation ---
  cat("Creating plot for:", effect_column, "\n")
  
  # Calculate absolute sum of effect for mutation type M at orthosteric positions
  df <- scores_df %>%
    filter(pos %in% orthosteric_positions, mutation_type == "M") %>%
    group_by(pos) %>%
    summarize(abs_sum_effect = sum(abs(.data[[effect_column]]), na.rm = TRUE), .groups = 'drop') %>%
    mutate(pos = as.character(pos)) %>%
    # Include all orthosteric positions (fill missing with 0)
    right_join(data.frame(pos = as.character(orthosteric_positions)), by = "pos") %>%
    mutate(abs_sum_effect = ifelse(is.na(abs_sum_effect), 0, abs_sum_effect)) %>%
    arrange(as.numeric(pos))
  
  # Create filename based on effect column
  filename <- paste0("circos_abssum_", effect_column, ".pdf")
  
  # --- Save as PDF ---
  pdf(filename, width = 8, height = 9)
  
  # --- Circos Plot Setup ---
  circos.clear()
  circos.par(
    start.degree = 90,              # Start at top (12 o'clock)
    gap.after = 1,                  # Small gaps between sectors
    track.margin = c(0, 0),         # No track margins
    cell.padding = c(0, 0, 0, 0),   # No cell padding
    canvas.xlim = c(-1.2, 1.2),     # Canvas limits
    canvas.ylim = c(-1.4, 1.2)      # Extended bottom for better spacing
  )
  
  # Initialize circos with one sector per position
  circos.initialize(
    factors = df$pos,
    xlim = cbind(rep(0, nrow(df)), rep(1, nrow(df)))
  )
  
  # --- Create Radial Bar Plot ---
  circos.trackPlotRegion(
    ylim = c(0, max(df$abs_sum_effect, na.rm = TRUE)),
    factors = df$pos,
    track.height = 1.0,
    bg.border = NA,
    panel.fun = function(x, y) {
      # Get current position and its value
      pos_label <- get.cell.meta.data("sector.index")
      val <- df$abs_sum_effect[df$pos == pos_label]
      
      # Draw bar
      circos.barplot(val, 1, col = "grey60", border = NA)
      
      # Add position labels
      circos.text(0.5, val + max(df$abs_sum_effect) * 0.05, pos_label,
                  facing = "downward",
                  niceFacing = FALSE,
                  adj = c(0.5, 0),
                  cex = 0.6)
    }
  )
  
  # --- Add Y-axis Reference ---
  circos.yaxis(
    side = "left",
    at = seq(0, max(df$abs_sum_effect), length.out = 5),
    labels = round(seq(0, max(df$abs_sum_effect), length.out = 5), 2),
    labels.cex = 0.6
  )
  
  # Clean up circos before adding title
  circos.clear()
  
  # --- Add Title ---
  title_text <- paste("Absolute Sum", gsub("effect_", "", effect_column), "Effect")
  subtitle_text <- "Orthosteric Positions (Mutation M)"
  
  # Add title using text() for precise positioning
  text(x = 0.5, y = 0.95, title_text, 
       cex = 1.3, font = 2, xpd = TRUE)
  text(x = 0.5, y = 0.90, subtitle_text, 
       cex = 1.1, font = 1, xpd = TRUE)
  
  # Close PDF
  dev.off()
  
  # --- Summary ---
  cat("PDF saved as:", filename, "\n")
  cat("Plot created for", nrow(df), "orthosteric positions\n")
  cat("Absolute sum range:", round(range(df$abs_sum_effect, na.rm = TRUE), 3), "\n\n")
  
  return(filename)
}

# =============================================================================
# GENERATE PLOTS FOR ALL EFFECT COLUMNS
# =============================================================================

# Find all columns starting with "effect_"
effect_columns <- names(scores)[grepl("^effect_", names(scores))]
cat("Found effect columns:", paste(effect_columns, collapse = ", "), "\n\n")

# Generate plots for all effect columns
generated_files <- sapply(effect_columns, function(col) {
  create_circos_plot(col, scores, orthosteric_pos)
})

# Summary of all generated files
cat("=== SUMMARY ===\n")
cat("Generated", length(generated_files), "circos plots (absolute sum):\n")
for(i in seq_along(generated_files)) {
  cat(i, ".", generated_files[i], "\n")
}
```

same radar plots but now using the expression normalized effects
```{r}
# =============================================================================
# GENERATE PLOTS FOR ALL EFFECT COLUMNS
# =============================================================================

# Find all columns starting with "effect_"
effect_columns <- names(scores_expression_normalized)[grepl("^effect_", names(scores_expression_normalized))]
cat("Found effect columns:", paste(effect_columns, collapse = ", "), "\n\n")

# Generate plots for all effect columns
generated_files <- sapply(effect_columns, function(col) {
  create_circos_plot(col, scores_expression_normalized, orthosteric_pos)
})

# Summary of all generated files
cat("=== SUMMARY ===\n")
cat("Generated", length(generated_files), "circos plots:\n")
for(i in seq_along(generated_files)) {
  cat(i, ".", generated_files[i], "\n")
}
```

# bar plots
similar to the radar just standard bar plots for othosteric resi to look at importance
```{r}
# =============================================================================
# FUNCTION: Create Bar Plot for Effect Columns (Absolute Sum) - CATEGORICAL
# =============================================================================

create_barplot <- function(effect_column, scores_df, orthosteric_positions, 
                          threshold = 0.5, output_dir = "bar_plots") {
  
  # --- Data Preparation ---
  cat("Creating bar plot for:", effect_column, "\n")
  
  # Calculate absolute sum of effect for mutation type M at orthosteric positions
  df <- scores_df %>%
    filter(pos %in% orthosteric_positions, mutation_type == "M") %>%
    group_by(pos) %>%
    summarize(abs_sum_effect = sum(abs(.data[[effect_column]]), na.rm = TRUE), .groups = 'drop') %>%
    mutate(pos = as.character(pos)) %>%
    # Include all orthosteric positions (fill missing with 0)
    right_join(data.frame(pos = as.character(orthosteric_positions)), by = "pos") %>%
    mutate(abs_sum_effect = ifelse(is.na(abs_sum_effect), 0, abs_sum_effect))
  
  # Filter positions based on threshold
  df_filtered <- df %>%
    filter(abs_sum_effect >= threshold) %>%
    arrange(as.numeric(pos)) %>%
    # Convert to factor for categorical treatment - this ensures even spacing
    mutate(pos_factor = factor(pos, levels = pos))
  
  # Check if we have data after filtering
  if(nrow(df_filtered) == 0) {
    cat("Warning: No positions meet threshold >= ", threshold, " for ", effect_column, "\n")
    return(NULL)
  }
  
  cat("Positions meeting threshold (>=", threshold, "):", nrow(df_filtered), "\n")
  
  # --- Create Bar Plot ---
  # Generate clean effect name for title
  effect_name <- gsub("effect_", "", effect_column)
  effect_name <- gsub("_", " ", effect_name)
  effect_name <- tools::toTitleCase(effect_name)
  
  p <- ggplot(df_filtered, aes(x = pos_factor, y = abs_sum_effect)) +
    geom_col(fill = "grey60", color = "black", width = 0.8) +
    labs(
      title = paste("Position Effect Scores (Score â‰¥", threshold, ")"),
      subtitle = paste("Absolute sum of", effect_name, "effects for mutation type M"),
      x = "Position",
      y = "Score (Absolute Sum Effect)"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5, size = 11),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.text.y = element_text(size = 10),
      axis.title = element_text(size = 12),
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_blank()  # Remove vertical grid lines for cleaner categorical look
    ) +
    scale_x_discrete() +  # Categorical x-axis with even spacing
    scale_y_continuous(expand = expansion(mult = c(0, 0.05)))
  
  # --- Save Plot ---
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
  }
  
  # Generate filename
  filename_base <- paste0("barplot_categorical_", effect_column, "_threshold_", threshold)
  
  # Save as PDF
  pdf_path <- file.path(output_dir, paste0(filename_base, ".pdf"))
  ggsave(
    filename = pdf_path,
    plot = p,
    width = 12,
    height = 6,
    units = "in",
    device = "pdf"
  )
  
  # Save as PNG
  png_path <- file.path(output_dir, paste0(filename_base, ".png"))
  ggsave(
    filename = png_path,
    plot = p,
    width = 12,
    height = 6,
    units = "in",
    device = "png",
    dpi = 300
  )
  
  # --- Summary ---
  cat("Bar plot saved to:\n")
  cat("PDF:", pdf_path, "\n")
  cat("PNG:", png_path, "\n")
  cat("Score range:", round(range(df_filtered$abs_sum_effect, na.rm = TRUE), 3), "\n\n")
  
  return(list(pdf = pdf_path, png = png_path, plot = p))
}

# =============================================================================
# GENERATE BAR PLOTS FOR ALL EFFECT COLUMNS
# =============================================================================

# Find all columns starting with "effect_"
effect_columns <- names(scores_expression_normalized)[grepl("^effect_", names(scores_expression_normalized))]
cat("Found effect columns:", paste(effect_columns, collapse = ", "), "\n\n")

threshold <- 0  # Adjust as needed
output_directory <- "bar_plots_categorical"  # Updated directory name

# Generate bar plots for all effect columns
generated_plots <- lapply(effect_columns, function(col) {
  create_barplot(col, scores_expression_normalized, orthosteric_pos, threshold, output_directory)
})

```


# specificty/selectivity analysis (rank order analysis)
look at rank ordering of orthosteric site effects for each ligand and compare to see which are general vs specific effects, etc etc
```{r}
analyze_drug_effects <- function(df, 
                                positions = NULL, 
                                mutation_type = "M",
                                score_threshold = 3,
                                output_dir = NULL,
                                save_plots = TRUE,
                                plot_width = 14,
                                plot_height = 6,
                                exclude_pattern = NULL) {
  
  # Load required libraries
  require(dplyr)
  require(ggplot2)
  require(tidyr)
  require(RColorBrewer)
  
  # Auto-detect effect columns
  effect_cols <- names(df)[grepl("^effect.*_norm$", names(df))]
  
  # Exclude patterns if specified
  if(!is.null(exclude_pattern)) {
    effect_cols <- effect_cols[!grepl(exclude_pattern, effect_cols, ignore.case = TRUE)]
  }
  
  if(length(effect_cols) == 0) {
    stop("No columns starting with 'effect' and ending with '_norm' found in the dataframe after filtering")
  }
  
  cat("Detected effect columns:", paste(effect_cols, collapse = ", "), "\n")
  
  # Extract drug names from column names
  drug_names <- gsub("^effect_(.+)_expr_norm$|^effect_(.+)_norm$", "\\1\\2", effect_cols)
  drug_names <- gsub("_expr$", "", drug_names) # Remove _expr if present
  
  cat("Detected drugs:", paste(drug_names, collapse = ", "), "\n")
  
  # If positions not provided, use all available positions
  if(is.null(positions)) {
    positions <- unique(df$pos[df$mutation_type == mutation_type])
    positions <- positions[!is.na(positions)]
    cat("Using all available positions:", length(positions), "positions\n")
  }
  
  # Calculate scores for all detected drugs
  score_data <- df %>%
    filter(pos %in% positions, mutation_type == mutation_type)
  
  # Dynamically create score calculations
  score_calcs <- list()
  for(i in 1:length(effect_cols)) {
    col_name <- effect_cols[i]
    score_name <- paste0(drug_names[i], "_score")
    score_calcs[[score_name]] <- bquote(sum(abs(.(as.name(col_name))), na.rm = TRUE))
  }
  
  df_multi_drug <- score_data %>%
    group_by(pos) %>%
    summarize(!!!score_calcs, .groups = 'drop') %>%
    mutate(pos = as.character(pos)) %>%
    # Ensure all positions are included
    right_join(data.frame(pos = as.character(positions)), by = "pos") %>%
    mutate_at(vars(ends_with("_score")), ~ifelse(is.na(.), 0, .)) %>%
    arrange(as.numeric(pos))
  
  # Calculate percentiles for all drugs
  score_cols <- names(df_multi_drug)[grepl("_score$", names(df_multi_drug))]
  
  df_percentile <- df_multi_drug
  for(score_col in score_cols) {
    percentile_col <- gsub("_score$", "_percentile", score_col)
    df_percentile[[percentile_col]] <- 100 * (rank(df_percentile[[score_col]], ties.method = "average") - 1) / (nrow(df_percentile) - 1)
  }
  
  # Filter for positions with any drug score >= threshold
  filter_condition <- df_percentile %>%
    select(all_of(score_cols)) %>%
    apply(1, function(x) any(x >= score_threshold, na.rm = TRUE))
  
  plot_data <- df_percentile[filter_condition, ] %>%
    mutate(pos_numeric = as.numeric(pos)) %>%
    arrange(pos_numeric)
  
  if(nrow(plot_data) == 0) {
    stop(paste("No positions found with any drug score >=", score_threshold))
  }
  
  # Create color palette for drugs
  n_drugs <- length(drug_names)
  if(n_drugs <= 3) {
    colors <- c("steelblue", "orange", "darkgreen")[1:n_drugs]
  } else if(n_drugs <= 8) {
    colors <- RColorBrewer::brewer.pal(min(n_drugs, 8), "Set2")
  } else {
    colors <- rainbow(n_drugs)
  }
  names(colors) <- drug_names
  
  # PLOT 1: Multi-way comparison (side-by-side bars)
  percentile_cols <- names(plot_data)[grepl("_percentile$", names(plot_data))]
  
  plot_data_long <- plot_data %>%
    select(pos, pos_numeric, all_of(percentile_cols)) %>%
    pivot_longer(
      cols = all_of(percentile_cols),
      names_to = "drug",
      values_to = "percentile"
    ) %>%
    mutate(
      drug = gsub("_percentile$", "", drug)
    ) %>%
    arrange(pos_numeric)
  
  p_comparison <- ggplot(plot_data_long, aes(x = factor(pos_numeric), y = percentile, fill = drug)) +
    geom_col(position = "dodge", color = "black", width = 0.8) +
    scale_fill_manual(values = colors) +
    labs(
      title = paste("Multi-Drug Comparison: Position Importance"),
      subtitle = paste("Percentile ranks for", paste(drug_names, collapse = ", ")),
      x = "Position",
      y = "Percentile Rank (0-100)",
      fill = "Drug"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5, size = 11),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.text.y = element_text(size = 10),
      axis.title = element_text(size = 12),
      legend.position = "top",
      panel.grid.minor = element_blank()
    ) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.05)))
  
  # PLOT 2: Drug specificity analysis
  # Calculate coefficient of variation across all drugs for each position
  percentile_matrix <- plot_data %>%
    select(all_of(percentile_cols)) %>%
    as.matrix()
  
  plot_data_specificity <- plot_data %>%
    mutate(
      mean_percentile = rowMeans(percentile_matrix, na.rm = TRUE),
      # Calculate standard deviation across drugs for each position
      sd_percentile = apply(percentile_matrix, 1, sd, na.rm = TRUE),
      # Coefficient of variation
      cv = ifelse(mean_percentile > 0, (sd_percentile / mean_percentile) * 100, 0),
      specificity_level = case_when(
        cv < 20 ~ "Low specificity\n(similar across drugs)",
        cv < 50 ~ "Moderate specificity", 
        TRUE ~ "High specificity\n(drug-specific)"
      )
    ) %>%
    arrange(pos_numeric)
  
  p_specificity <- ggplot(plot_data_specificity, aes(x = factor(pos_numeric), y = cv, fill = specificity_level)) +
    geom_col(color = "black", width = 0.8) +
    scale_fill_manual(values = c(
      "Low specificity\n(similar across drugs)" = "gray70",
      "Moderate specificity" = "orange", 
      "High specificity\n(drug-specific)" = "red"
    )) +
    labs(
      title = "Drug Specificity by Position",
      subtitle = "Higher bars = more drug-specific effects",
      x = "Position",
      y = "Coefficient of Variation (%)",
      fill = "Specificity Level"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5, size = 11),
      axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.text.y = element_text(size = 10),
      axis.title = element_text(size = 12),
      legend.position = "top",
      panel.grid.minor = element_blank()
    ) +
    scale_y_continuous(expand = expansion(mult = c(0, 0.05)))
  
  # Print the plots
  print(p_comparison)
  print(p_specificity)
  
  # Save plots if requested
  if(save_plots && !is.null(output_dir)) {
    if (!dir.exists(output_dir)) {
      dir.create(output_dir, recursive = TRUE)
    }
    
    timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")
    
    # Save comparison plot
    ggsave(
      filename = file.path(output_dir, paste0("multi_drug_comparison_", timestamp, ".pdf")),
      plot = p_comparison,
      width = plot_width,
      height = plot_height,
      units = "in"
    )
    
    # Save specificity plot
    ggsave(
      filename = file.path(output_dir, paste0("drug_specificity_", timestamp, ".pdf")),
      plot = p_specificity,
      width = plot_width,
      height = plot_height,
      units = "in"
    )
    
    cat("\nPlots saved to:", output_dir, "\n")
  }
  
  # Return results
  return(list(
    data = df_multi_drug,
    percentile_data = df_percentile,
    plot_data = plot_data,
    specificity_data = plot_data_specificity,
    comparison_plot = p_comparison,
    specificity_plot = p_specificity,
    drug_names = drug_names,
    effect_columns = effect_cols
  ))
}

# Convenience function to analyze and create summary statistics
summarize_drug_analysis <- function(analysis_results, top_n = 10) {
  
  df_percentile <- analysis_results$percentile_data
  drug_names <- analysis_results$drug_names
  
  cat("=== DRUG ANALYSIS SUMMARY ===\n")
  cat("Drugs analyzed:", paste(drug_names, collapse = ", "), "\n")
  cat("Total positions analyzed:", nrow(df_percentile), "\n")
  
  # Calculate ranks for all drugs
  score_cols <- names(df_percentile)[grepl("_score$", names(df_percentile))]
  df_ranked <- df_percentile
  
  for(score_col in score_cols) {
    rank_col <- gsub("_score$", "_rank", score_col)
    df_ranked[[rank_col]] <- rank(-df_ranked[[score_col]], ties.method = "min")
  }
  
  # Top positions for each drug
  cat("\n=== TOP", top_n, "POSITIONS BY DRUG ===\n")
  
  for(i in 1:length(drug_names)) {
    drug <- drug_names[i]
    score_col <- paste0(drug, "_score")
    rank_col <- paste0(drug, "_rank")
    
    cat("\n", toupper(drug), ":\n", sep="")
    top_positions <- df_ranked %>%
      filter(!!sym(score_col) >= 3) %>%
      arrange(!!sym(rank_col)) %>%
      head(top_n) %>%
      select(pos, !!sym(score_col), !!sym(rank_col))
    print(top_positions)
  }
  
  # Find universal and specific positions
  rank_cols <- names(df_ranked)[grepl("_rank$", names(df_ranked))]
  top5_lists <- list()
  
  for(i in 1:length(rank_cols)) {
    drug_name <- gsub("_rank$", "", rank_cols[i])
    top5_lists[[drug_name]] <- df_ranked %>% 
      filter(!!sym(rank_cols[i]) <= 5) %>% 
      pull(pos)
  }
  
  cat("\n=== DRUG-SPECIFIC ANALYSIS (TOP 5) ===\n")
  for(drug in names(top5_lists)) {
    cat(toupper(drug), "top 5:", paste(top5_lists[[drug]], collapse = ", "), "\n")
  }
  
  # Find universal positions (top 5 for all drugs)
  if(length(top5_lists) > 1) {
    universal_positions <- Reduce(intersect, top5_lists)
    cat("Universal hotspots (top 5 for all drugs):", 
        ifelse(length(universal_positions) > 0, paste(universal_positions, collapse = ", "), "None"), "\n")
    
    # Find drug-specific positions
    for(drug in names(top5_lists)) {
      other_drugs <- setdiff(names(top5_lists), drug)
      other_positions <- Reduce(union, top5_lists[other_drugs])
      specific_positions <- setdiff(top5_lists[[drug]], other_positions)
      cat(paste0(drug, "-specific positions:"), 
          ifelse(length(specific_positions) > 0, paste(specific_positions, collapse = ", "), "None"), "\n")
    }
  }
  
  return(df_ranked)
}

# Example usage:
results <- analyze_drug_effects(
  df = scores_expression_normalized,  # your dataframe
  positions = positions,  # optional, will auto-detect if NULL
  mutation_type = "M",
  score_threshold = 0,
  output_dir = output_dir,
  save_plots = TRUE,
  exclude_pattern = "FSK|Naloxone"  # excludes columns containing "FSK" or "Naloxone"
)

# # Get summary statistics
ranked_data <- summarize_drug_analysis(results, top_n = 30)
```

attempts to try and cluster based on these results
```{r}
cluster_drug_effects <- function(analysis_results, 
                                n_clusters = 4,
                                clustering_method = "ward.D2",
                                output_dir = NULL,
                                save_plots = TRUE) {
  
  require(cluster)
  require(factoextra)
  require(pheatmap)
  require(corrplot)
  require(gridExtra)
  require(RColorBrewer)
  
  # Check for optional packages
  has_ggdendro <- requireNamespace("ggdendro", quietly = TRUE)
  
  # Extract data
  df_percentile <- analysis_results$percentile_data
  drug_names <- analysis_results$drug_names
  
  # Get percentile columns
  percentile_cols <- names(df_percentile)[grepl("_percentile$", names(df_percentile))]
  score_cols <- names(df_percentile)[grepl("_score$", names(df_percentile))]
  
  # Create matrix for clustering (positions x drugs)
  cluster_matrix <- df_percentile %>%
    filter(if_any(all_of(score_cols), ~ .x > 0)) %>%  # Remove positions with no effects
    select(pos, all_of(percentile_cols)) %>%
    column_to_rownames("pos") %>%
    as.matrix()
  
  # Clean drug names for column names
  colnames(cluster_matrix) <- gsub("_percentile$", "", colnames(cluster_matrix))
  
  cat("Clustering analysis on", nrow(cluster_matrix), "positions and", ncol(cluster_matrix), "drugs\n")
  
  # =================================================================
  # 1. POSITION CLUSTERING (positions with similar drug profiles)
  # =================================================================
  
  # Calculate distance between positions
  pos_dist <- dist(cluster_matrix, method = "euclidean")
  pos_hclust <- hclust(pos_dist, method = clustering_method)
  
  # Cut tree to get clusters
  pos_clusters <- cutree(pos_hclust, k = n_clusters)
  
  # Create position cluster summary
  pos_cluster_df <- data.frame(
    pos = names(pos_clusters),
    cluster = pos_clusters
  ) %>%
    left_join(df_percentile %>% select(pos, all_of(score_cols)), by = "pos")
  
  # =================================================================
  # 2. DRUG CLUSTERING (drugs with similar position profiles)
  # =================================================================
  
  # Transpose for drug clustering
  drug_dist <- dist(t(cluster_matrix), method = "euclidean")
  drug_hclust <- hclust(drug_dist, method = clustering_method)
  
  # =================================================================
  # 3. PRINCIPAL COMPONENT ANALYSIS
  # =================================================================
  
  pca_result <- prcomp(cluster_matrix, scale. = TRUE, center = TRUE)
  pca_summary <- summary(pca_result)
  
  # Add PCA coordinates to position data
  pca_coords <- as.data.frame(pca_result$x[, 1:min(4, ncol(pca_result$x))])
  pca_coords$pos <- rownames(pca_coords)
  pca_coords$cluster <- pos_clusters
  
  # =================================================================
  # 4. K-MEANS CLUSTERING
  # =================================================================
  
  set.seed(123)
  kmeans_result <- kmeans(cluster_matrix, centers = n_clusters, nstart = 25)
  
  # =================================================================
  # 5. VISUALIZATIONS
  # =================================================================
  
  # PLOT 1: Hierarchical clustering heatmap with dendrograms
  p1 <- pheatmap(
    cluster_matrix,
    clustering_distance_rows = "euclidean",
    clustering_distance_cols = "euclidean", 
    clustering_method = clustering_method,
    cutree_rows = n_clusters,
    scale = "none",
    color = colorRampPalette(c("white", "yellow", "orange", "red", "darkred"))(100),
    main = "Position-Drug Effect Heatmap with Clustering",
    fontsize = 8,
    silent = TRUE
  )
  
  # PLOT 2: Position dendrogram with cluster colors
  if(has_ggdendro) {
    dend_data <- ggdendro::dendro_data(pos_hclust)
    dend_data$labels$cluster <- pos_clusters[dend_data$labels$label]
    
    p2 <- ggplot(dend_data$segments) +
      geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) +
      geom_text(data = dend_data$labels, 
                aes(x = x, y = y, label = label, color = factor(cluster)), 
                hjust = 1, angle = 90, size = 3) +
      scale_color_brewer(type = "qual", palette = "Set2", name = "Cluster") +
      labs(title = "Position Clustering Dendrogram", x = "", y = "Height") +
      theme_minimal() +
      theme(axis.text.x = element_blank(),
            axis.ticks.x = element_blank())
  } else {
    # Alternative: simple base R dendrogram
    cat("ggdendro package not available, using base R dendrogram\n")
    p2 <- NULL  # Will create base R plot later
  }
  
  # PLOT 3: PCA biplot
  # Prepare PCA data for plotting
  pca_var <- get_pca_var(pca_result)
  
  p3a <- ggplot(pca_coords, aes(x = PC1, y = PC2, color = factor(cluster))) +
    geom_point(size = 3, alpha = 0.7) +
    geom_text(aes(label = pos), vjust = -0.5, hjust = 0.5, size = 2.5) +
    scale_color_brewer(type = "qual", palette = "Set2", name = "Cluster") +
    labs(
      title = "PCA: Positions by Drug Response Profile",
      x = paste0("PC1 (", round(pca_summary$importance[2,1]*100, 1), "%)"),
      y = paste0("PC2 (", round(pca_summary$importance[2,2]*100, 1), "%)")
    ) +
    theme_minimal()
  
  # PLOT 4: Drug loading plot
  drug_loadings <- as.data.frame(pca_result$rotation[, 1:2])
  drug_loadings$drug <- rownames(drug_loadings)
  
  p3b <- ggplot(drug_loadings, aes(x = PC1, y = PC2)) +
    geom_point(size = 4, color = "red", alpha = 0.7) +
    geom_text(aes(label = drug), vjust = -0.5, hjust = 0.5) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha = 0.5) +
    labs(
      title = "PCA: Drug Loadings",
      x = "PC1 Loading", 
      y = "PC2 Loading"
    ) +
    theme_minimal()
  
  # PLOT 5: Cluster profiles (mean percentile by drug for each cluster)
  cluster_profiles <- pos_cluster_df %>%
    select(cluster, all_of(score_cols)) %>%
    group_by(cluster) %>%
    summarise(across(everything(), mean, na.rm = TRUE), .groups = 'drop') %>%
    pivot_longer(cols = -cluster, names_to = "drug", values_to = "mean_score") %>%
    mutate(drug = gsub("_score$", "", drug))
  
  p4 <- ggplot(cluster_profiles, aes(x = drug, y = mean_score, fill = factor(cluster))) +
    geom_col(position = "dodge", color = "black") +
    scale_fill_brewer(type = "qual", palette = "Set2", name = "Cluster") +
    labs(
      title = "Cluster Profiles: Mean Drug Effects",
      x = "Drug", 
      y = "Mean Effect Score"
    ) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  # PLOT 6: Cluster size and composition
  cluster_composition <- pos_cluster_df %>%
    group_by(cluster) %>%
    summarise(
      n_positions = n(),
      positions = paste(pos, collapse = ", "),
      .groups = 'drop'
    )
  
  p5 <- ggplot(cluster_composition, aes(x = factor(cluster), y = n_positions, fill = factor(cluster))) +
    geom_col(color = "black") +
    geom_text(aes(label = n_positions), vjust = -0.3) +
    scale_fill_brewer(type = "qual", palette = "Set2", name = "Cluster") +
    labs(
      title = "Cluster Sizes",
      x = "Cluster", 
      y = "Number of Positions"
    ) +
    theme_minimal()
  
  # PLOT 7: Drug correlation matrix
  drug_cor <- cor(cluster_matrix, use = "complete.obs")
  
  p6 <- corrplot(drug_cor, 
                 method = "color",
                 type = "upper",
                 order = "hclust",
                 addrect = 2,
                 title = "Drug Correlation Matrix",
                 mar = c(0,0,1,0))
  
  # Print plots
  print(p1)
  if(!is.null(p2)) {
    print(p2)
  } else {
    # Create base R dendrogram
    plot(pos_hclust, main = "Position Clustering Dendrogram", 
         labels = names(pos_clusters), cex = 0.8)
    rect.hclust(pos_hclust, k = n_clusters, border = 2:5)
  }
  print(p3a)
  print(p3b)
  print(p4)
  print(p5)
  
  # Print cluster composition
  cat("\n=== POSITION CLUSTER COMPOSITION ===\n")
  for(i in 1:n_clusters) {
    cluster_pos <- pos_cluster_df %>% filter(cluster == i) %>% pull(pos)
    cat("Cluster", i, "(", length(cluster_pos), "positions ):", paste(cluster_pos, collapse = ", "), "\n")
  }
  
  # Statistical summary
  cat("\n=== CLUSTERING STATISTICS ===\n")
  cat("Variance explained by PC1:", round(pca_summary$importance[2,1]*100, 1), "%\n")
  cat("Variance explained by PC2:", round(pca_summary$importance[2,2]*100, 1), "%\n")
  cat("Total variance explained by PC1-PC2:", round(sum(pca_summary$importance[2,1:2])*100, 1), "%\n")
  
  # Within-cluster sum of squares for k-means
  cat("K-means within-cluster SS:", round(kmeans_result$tot.withinss, 2), "\n")
  cat("K-means between-cluster SS:", round(kmeans_result$betweenss, 2), "\n")
  
  # Save plots if requested
  if(save_plots && !is.null(output_dir)) {
    timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")
    
    # Save heatmap
    pdf(file.path(output_dir, paste0("clustering_heatmap_", timestamp, ".pdf")), width = 12, height = 8)
    print(p1)
    dev.off()
    
    # Save other plots
    if(!is.null(p2)) {
      ggsave(file.path(output_dir, paste0("position_dendrogram_", timestamp, ".pdf")), p2, width = 12, height = 8)
    } else {
      # Save base R dendrogram
      pdf(file.path(output_dir, paste0("position_dendrogram_", timestamp, ".pdf")), width = 12, height = 8)
      plot(pos_hclust, main = "Position Clustering Dendrogram", labels = names(pos_clusters), cex = 0.8)
      rect.hclust(pos_hclust, k = n_clusters, border = 2:5)
      dev.off()
    }
    ggsave(file.path(output_dir, paste0("pca_positions_", timestamp, ".pdf")), p3a, width = 10, height = 8)
    ggsave(file.path(output_dir, paste0("pca_drugs_", timestamp, ".pdf")), p3b, width = 8, height = 6)
    ggsave(file.path(output_dir, paste0("cluster_profiles_", timestamp, ".pdf")), p4, width = 10, height = 6)
    ggsave(file.path(output_dir, paste0("cluster_sizes_", timestamp, ".pdf")), p5, width = 8, height = 6)
    
    # Save correlation plot
    pdf(file.path(output_dir, paste0("drug_correlations_", timestamp, ".pdf")), width = 8, height = 8)
    corrplot(drug_cor, method = "color", type = "upper", order = "hclust", addrect = 2, title = "Drug Correlation Matrix")
    dev.off()
    
    cat("Clustering plots saved to:", output_dir, "\n")
  }
  
  # Return comprehensive results
  return(list(
    position_clusters = pos_cluster_df,
    cluster_composition = cluster_composition,
    pca_result = pca_result,
    pca_coords = pca_coords,
    drug_correlations = drug_cor,
    kmeans_result = kmeans_result,
    hierarchical_clustering = pos_hclust,
    drug_clustering = drug_hclust,
    cluster_matrix = cluster_matrix,
    plots = list(
      heatmap = p1,
      dendrogram = p2,  # May be NULL if ggdendro not available
      pca_positions = p3a,
      pca_drugs = p3b,
      cluster_profiles = p4,
      cluster_sizes = p5
    )
  ))
}

# Function to find optimal number of clusters
find_optimal_clusters <- function(analysis_results, max_k = 10) {
  
  require(factoextra)
  
  # Extract matrix
  df_percentile <- analysis_results$percentile_data
  percentile_cols <- names(df_percentile)[grepl("_percentile$", names(df_percentile))]
  score_cols <- names(df_percentile)[grepl("_score$", names(df_percentile))]
  
  cluster_matrix <- df_percentile %>%
    filter(if_any(all_of(score_cols), ~ .x > 0)) %>%
    select(pos, all_of(percentile_cols)) %>%
    column_to_rownames("pos") %>%
    as.matrix()
  
  # Elbow method
  wss <- fviz_nbclust(cluster_matrix, kmeans, method = "wss", k.max = max_k)
  
  # Silhouette method  
  sil <- fviz_nbclust(cluster_matrix, kmeans, method = "silhouette", k.max = max_k)
  
  # Gap statistic
  gap <- fviz_nbclust(cluster_matrix, kmeans, method = "gap_stat", k.max = max_k)
  
  print(wss)
  print(sil) 
  print(gap)
  
  return(list(wss = wss, silhouette = sil, gap_stat = gap))
}

# Usage example:
# # Optional: install additional packages for enhanced plots
# # install.packages("ggdendro")
# 
# # First run the basic analysis
# results <- analyze_drug_effects(df = normalized, ...)
# 
# # Find optimal number of clusters
optimal_k <- find_optimal_clusters(results, max_k = 8)
# 
# # Run clustering analysis
cluster_results <- cluster_drug_effects(
  analysis_results = results,
  n_clusters = 2,  # Use optimal k from above
  output_dir = output_dir
)

```